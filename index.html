<!DOCTYPE html>
<html>

<head>
  <title>Three.js Image Tracking Example (MindAR)</title>
  <script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
    "mindar-image-three":"https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-three.prod.js"
  }
}
</script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: sans-serif;
    }

    #container {
      width: 100vw;
      height: 100vh;
      position: absolute;
    }

    #spin-toggle {
      position: absolute;
      top: 32px;
      left: 32px;
      z-index: 10;
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      background: rgba(0, 0, 0, 0.7);
      color: #fff;
      cursor: pointer;
      font-size: xx-large;
    }

    #intro-overlay {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: #000;
      z-index: 200;
      transition: opacity 0.4s ease;
    }

    #intro-overlay.fade-out {
      opacity: 0;
      pointer-events: none;
    }

    #intro-frame {
      width: min(92vw, 92vh);
      max-height: 92vh;
      object-fit: contain;
    }
  </style>
</head>

<body>
  <div id="intro-overlay">
    <img id="intro-frame" alt="Loading animation">
  </div>
  <div id="container"></div>
  <button id="spin-toggle" type="button">Start Spin</button>
  <script type="module">
    import * as THREE from 'three';
    import { MindARThree } from 'mindar-image-three';
    import { GLTFLoader } from "https://cdn.rawgit.com/mrdoob/three.js/master/examples/jsm/loaders/GLTFLoader.js"
    import { RGBELoader } from "https://cdn.rawgit.com/mrdoob/three.js/master/examples/jsm/loaders/RGBELoader.js"


    document.addEventListener("DOMContentLoaded", async () => {
      await playIntroAnimation();
      const mindarThree = new MindARThree({
        container: document.querySelector("#container"),
        imageTargetSrc: "public/targets/targets.mind", // <-- Use your compiled .mind file
        missTolerance: 100, // increase missTolerance to avoid flickering
        filterMinCF: 0.9,
      });
      const { renderer, scene, camera } = mindarThree;

      const clock = new THREE.Clock();
      const btn = document.getElementById("spin-toggle");
      let spinEnabled = false;
      btn.addEventListener("click", () => {
        spinEnabled = !spinEnabled;
        btn.textContent = spinEnabled ? "Stop Spin" : "Start Spin";
      });

      const hdrLoader = new RGBELoader();
      hdrLoader.setDataType(THREE.HalfFloatType);
      hdrLoader.load('public/background.hdr', (texture) => {
        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        pmremGenerator.compileEquirectangularShader();
        const envMap = pmremGenerator.fromEquirectangular(texture).texture;
        scene.environment = envMap;
        texture.dispose();
        pmremGenerator.dispose();
      });

      const loader = new GLTFLoader();

      const finalPosition = new THREE.Vector3(0, -2, 0);
      const finalScale = new THREE.Vector3(0.4, 0.4, 0.4);
      const startScale = finalScale.clone().multiplyScalar(0.6);
      const entryOffset = 0.6;
      const entryDuration = 0.4;
      let entryElapsed = entryDuration;
      let modelScene = null;

      loader.load('public/models/scene.gltf', (gltf) => {
        modelScene = gltf.scene || gltf.scenes?.[0] || gltf;
        modelScene.visible = false;
        modelScene.position.copy(finalPosition);
        modelScene.scale.copy(finalScale);
        modelScene.rotation.set(0, 0, 0);

        const anchor = mindarThree.addAnchor(0);
        anchor.group.add(modelScene);

        anchor.onTargetFound = () => {
          if (!modelScene) return;
          modelScene.visible = true;
          modelScene.position.copy(finalPosition);
          modelScene.position.z -= entryOffset;
          modelScene.scale.copy(startScale);
          entryElapsed = 0;
        };

        anchor.onTargetLost = () => {
          if (modelScene) modelScene.visible = false;
        };
      });

      await mindarThree.start();
      renderer.setAnimationLoop(() => {
        const delta = clock.getDelta();

        if (modelScene && entryElapsed < entryDuration) {
          entryElapsed += delta;
          const t = Math.min(entryElapsed / entryDuration, 1);
          const ease = t * t * (3 - 2 * t);
          modelScene.position.z = THREE.MathUtils.lerp(finalPosition.z - entryOffset, finalPosition.z, ease);
          modelScene.scale.lerpVectors(startScale, finalScale, ease);
        }

        if (spinEnabled && modelScene && modelScene.visible) {
          modelScene.rotation.y += delta * 0.4;
        }

        renderer.render(scene, camera);
      });
    });

    function playIntroAnimation() {
      const frameCount = 19;
      const frameBasePath = "public/intro";
      const fps = 15;
      const overlay = document.getElementById("intro-overlay");
      const frameEl = document.getElementById("intro-frame");
      const framePaths = Array.from({ length: frameCount }, (_, i) =>
        `${frameBasePath}/${String(i + 1).padStart(4, "0")}.png`
      );
      const preloadImage = (src) => new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = resolve;
        img.onerror = reject;
        img.src = src;
      });
      const forward = Array.from({ length: frameCount }, (_, i) => i);
      const backward = Array.from({ length: frameCount }, (_, i) => frameCount - 1 - i);
      const sequences = ["forward", "backward", "forward"];
      const playbackOrder = [];
      sequences.forEach((direction, index) => {
        const frames = direction === "forward" ? forward : backward;
        playbackOrder.push(...(index === 0 ? frames : frames.slice(1)));
      });

      return new Promise((resolve) => {
        if (!overlay || !frameEl || playbackOrder.length === 0) {
          resolve();
          return;
        }
        Promise.all(framePaths.map(preloadImage))
          .then(() => {
            overlay.style.display = "flex";
            overlay.classList.remove("fade-out");
            let current = 0;
            frameEl.src = framePaths[playbackOrder[current]];
            const interval = setInterval(() => {
              current += 1;
              if (current >= playbackOrder.length) {
                clearInterval(interval);
                overlay.classList.add("fade-out");
                setTimeout(() => {
                  overlay.style.display = "none";
                  resolve();
                }, 400);
                return;
              }
              frameEl.src = framePaths[playbackOrder[current]];
              // increase frameEL size
              frameEl.style.width = `min(92vw, 92vh)`;
              frameEl.style.maxHeight = `92vh`;
            }, 1000 / fps);
          })
          .catch((error) => {
            console.warn("Intro animation skipped:", error);
            overlay.style.display = "none";
            resolve();
          });
      });
    }

    async function startMindarExperience() {
    }
  </script>
</body>

</html>